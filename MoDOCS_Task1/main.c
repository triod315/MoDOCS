// This file is part of AOCS_Task1 which is released under MIT License.
// Created by triod315 on 10/31/21, 10:19 PM
// Copyright (c) 2021.

/*
 *  Програма зчитує з консолі розмір масиву, потім сам масив і переміщує всі ненульві елементи на початок масиву.
 *  Для того щоб уникнення створення нового масиву програма використовує зсув елментів вправо. А саме, для цього
 *  перебирається масив зліва на право, і якщо знаходиться ненульвий елемент то виконується циклічний зсув вправо
 *  для лівої підчастини масиву, яка знаходяться зліва в межах від передостаннього знайденого ненульового елементу
 *  до останнього знайденого ненульового елементу.
 */
#include <stdio.h>
/// Вивід масиву в консоль
/// \param array - масиву для виводу
/// \param N - розмір масиву
void printArray(int array[],int N) {
    for (int i = 0; i < N; i++)
        printf("%d ", *(array+i));
}
int main() {
    // розмір вхідного самиву
    int N;
    // зчитування розміру масиву
    scanf("%d",&N);
    int arr[N];
    // зчитування елементів масиву
    for (int i = 0; i < N; i++) {
        scanf("%d",arr+i);
    }
    // вивід масиву перед перетворенням
    printf("Before\n");
    printArray(arr, N);
    // позиція останнього знайденого ненульового елементу
    int k=-1;
    int x;
    // перевірка кожного елементу на рівність 0, якщо знаходимо елемент нерівний 0 то робимо зсув лівої підчастини
    // впарво, і запам'ятовуємо позицію останнцього знайденого ненульового елементу
    for (int i = 0; i < N; i++)
        if (*(arr+i)!=0) {
            // визначаємо куди встивити ненульовий елемент
            k++;
            // запам'ятовуємо значення елементу
            x=*(arr+i);
            // робимо зсув лівої частини масиву, заповненої нулями, вправо
            for (int j = i; j > k ; j--) {
                *(arr+j)=*(arr+j-1);
            }
            *(arr+k)=x;
        }
    // вивід перетвореного масиву
    printf("\nResult\n");
    printArray(arr, N);
    return 0;
}
